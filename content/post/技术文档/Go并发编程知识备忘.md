---
Categories: ["技术文档"]
Tags: ["golang"]
date: 2016-12-06T16:33:28+08:00
title: Go并发编程知识备忘
---

以下所有内容引自《Go语言并发编程》
###  初识Go语言
#### Go语言特性

 - 开放源代码的通用计算机编程语言
 - 虽为静态类型、编译型的语言，但Go语言的语法趋于脚本化,非常简洁
 - 卓越的跨平台支持，无需移植代码。跨平台主要指跨计算架构和操作系统
 - 全自动的垃圾回收机制，无需开发者干预
 - 原生的先进并发编程模型和机制
 - 拥有函数式编程范式的特性，函数为一等代码块
 - 无继承层次的轻量级面相对象编程范式
 - 内含完善、全面的软件工程工具
 - 代码风格强制统一
 - 程序编译和运行速度都非常快
 - 标准库丰富，极适合开发服务端程序和Web程序

#### Go语言的优劣
没有万能的编程语言，没有万能的开发框架，也没有万能的解决方案

任何新技术的产生都应该归功于一部分人对老旧技术的强烈不满。

Go语言是集多编程范式之大成者，体现了优秀的软件工程思想和原则，其特性可以使开发者快速地开发、测试和部署程序，大大提高了生产效率。

Go语言的优势

 - 相对于C/C++来讲，Go语言拥有清晰的依赖管理和全自动的垃圾回收机制，因此代码量大大降低，开发效率大大提高
 - 相对于Java来讲，Go语言拥有简明的类型系统、函数式编程范式和先进的并发编程模型。因此其代码块更小更简洁、可重用性更高，并可在多核计算环境下更快地运行
 - 对于PHP来讲，Go语言更具通用性和规范性。这使得其更适合构建大型的软件，并能够更好地将各个模块组织在一起。在性能方面，PHP不可与Go同日而语。
 - 对于Python/Ruby来讲，Go的优势在于其简洁的语法、非侵入式和扁平化的类型系统和浑然天成的多范式编程模型。与PHP一样,Python和Ruby是动态类型的解释型语言，这就意味着它们的运行速度会比静态类型的编译型语言慢很多。

总而言之，Go语言最大的优势在于具有较高的生产效率、先进的依赖管理和类型系统，以及原生的并发计算支持。

劣势暂略。。。

### Go语言环境搭建
#### 安装和设置
> wget https://storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz

> tar zxvf go1.6.linux-amd64.tar.gz

> sudo mv ./go /usr/local

> vim /etc/profile

    export GOROOT=/usr/local/go
    export PATH=$PATH:$GOROOT/bin

> source /etc/profile

Go语言还有两个隐含的环境变量---- GOOS和GOARCH

 - GOOS代表程序构建环境的目标操作系统，其值可以是darwin、freebsd、linux、windows
 - GOARCH代表程序构建环境的目标计算架构,其值可以是386、amd64、arm

"平台相关目录“就是用${GOOS}_${GOARCH}的方式来命名的。
这两个环境变量一般不需要显式设置，因为在Go语言安装包中，已经把这两个环境变量设置为常量，即标准库代码包runtime中的常量GOOS和GOARCH.


#### 工程结构
Go是一门推崇软件工程理念的编程语言。
Go语言高度强调代码和项目的规范和统一。
Go语言可以让程序开发者很容易地通过go get命令从各种公共代码库（比如GitHub)中下载开源代码并使用它们。

**工作区**
Go代码必须放在工作区中。包含三个子目录:src目录、pkg目录、bin目录。

 - src目录：用于以代码包的形式组织并保存Go源码文件。Go语言的源码文件分为3类：Go库源码文件、Go命令源码文件和Go测试源码文件。
 - pkg目录: 用于存放经由go install命令构建安装后的代码包（包含Go库源码文件)的".a" 归档文件。该目录与GOROOT目录下的pkg功能类似。区别在于，工作区中的pkg目录专门用来存放用户（也就是程序开发者）代码的归档文件。构建和安装用户源码的过程一般会以代码包为单位进行，例如logging包被编译安装后，将生成一个名为logging.a的归档文件。
 - bin目录：与pkg目录类似，在通过go install命令完成安装后，保存由Go命令源码文件生成的可执行文件。Linux操作系统下，这个可执行文件一般是一个与源码文件同名的文件。而Windows操作系统下，为源码文件名加.exe后缀。

> 命令源码文件，就是声明为属于main代码包，并且包含无参数声明和结果声明的main函数的源码文件。这类源码文件可以独立运行(使用go
> run命令),也可被go build或go install命令转换为可执行文件。而库源码文件则是指存在于某个代码包中的普通源码文件。

**GOPATH**
我们需要将工作区的目录路径添加至环境变量GOPATH中，否则，即使处于同一工作区，代码之间也无法通过绝对代码包路径完成调用。以Linux操作系统为例，若有两个工作区:

    ~/golang/lib
    ~/golang/goc2p

则需要修改/etc/profile文件，并加入设置环境变量GOPATH的内容:
> export GOPATH=$HOME/golang/lib:$HOME/golang/goc2p

注意：

 - GOPATH中不要包含环境变量GOROOT的值(即Go的安装目录路径),以此将Go语言本身的工作区同用户工作区严格地分开
 - 通过Go工具中的代码获取命令go get,可将指定项目的源码下载到我们在环境变量GOPATH中设定的第一个工作区中，并在其中完成构建和安装的过程。

> 我们约定，在$HOME/golang/lib目录中存放第三方代码库，而在$HOME/golang/goc2p目录中存放示例代码和附属代码库。

**代码包**

Go语言的代码包是对代码进行构建和打包的基本单元。

1、包声明
basic/set包中的所有源码文件都要先声明自己属于basic/set包：
> package set

Go语言规定包声明中的包名为代码包路径的最后一个元素。比如basic/set包的包路径为basic/set,而包声明中的包名则为set。但有一个例外，不论命令源码文件存放在哪个代码包中，它都必须声明为属于main包。

2、包导入
代码包的导入使用代码包导入路径。
代码包导入路径就是代码包在工作区的src目录下的相对路径
比如，代码包ctcp的绝对目录经历时~/golang/goc2p/src/cnet/ctcp,而~/golang/goc2p是被包含在环境变量GOPATH中的工作区目录路径，那么其代码包导入路径就是cnet/ctcp。
> import basic/set
> import helper/ds
> import cnet/ctcp
> import logging

如果我们有两个包logging和go_lib/logging,且有一个源码文件需要导入这两个包:

    import (
        "logging"
        "go_lib/logging"
    )

则这句代码logging.newSimpleLogger()就会引起冲突，Go语言无法知道logging.代表的是哪一个包。
结论：所以，在Go语言中，如果在同一个源码文件中导入多个代码包，那么代码包路径的最后一个元素不可以重复。
如果这种代码包确实有必要导入，那么我们又该怎么做呢？
当有这类重复时，我们可以给它们起个别名来区分，比如：

    import (
        la "logging"
        lb "go_lib/logging"
    )
之后，我们就可以调用包中的代码
> var logger la.Logger = la.NewSimpleLogger()

这里不必给每个引起冲突的代码包都起一个别名，只要能区分它们就可以了。

    import (
        . "logging"
        lb "go_lib/logging"
    )

之后，我们就可以调用包中的代码
> var logger Logger = newSimpleLogger()

如果我们只想初始化某个代码包而不需要在当前源码文件中使用那个代码包中的任何代码，就可以用"_"来代替别名

    import (
        _ "logging"
    )

3、包初始化
要求：需要无参数声明和结果声明，且名称必须为init,如下所示
func init() {
    println("Initialize...")
}
最后需要说明的是，Go语言认可两个特殊的代码包名称----all和std.all代表了环境变量GOPATH 中包含的所有工作区中的所有代码包,而std则代表了Go语言标准库中的所有代码包。

### 操作符
地址操作符

 - 取值操作符 *p *(&v)
 - 取址操作符 &p &(*p)

数组、切片类型取址  &a[0] &s[0]
结构类型取址 &s.F

接收操作符
<-ch   从此通道中接收一个值

 - 从一个通道类型的空值(即nil) 接收值的表达式将会永远被阻塞
 - 从一个已被关闭的通道类型接收值会永远成功并立即返回一个其元素类型的零值

一个由接收操作符和通道类型的操作数所组成的表达式可以直接被用于变量赋值或初始化

    v1 := <-ch
    v2 = <-ch

或

    v, ok = <-ch
    v,ok := <-ch

### 表达式
#### 基本表达式

1、基本表达式
> []int{1,2,3,4,5}[2] 这个表达式用语取出数组中索引为2的元素，所以此表达式的结果值为3

2、类型转换作为基本表达式
> int(v1) + v2 

3、使用内建函数调用作为基本表达式
> len(v3) 得出数组类型v3包含的元素的个数

4、一个基本表达式和一个选择符号可以组成另外一个基本表达式
> x.f  其中x为结构类型，f是其中的字段.注意，前提是这个变量x的值不能是nil. 

5、一个基本表达式和一个索引符号可以组成另外一个基本表达式－索引表达式
> []int{1,2,3,4,5}[1+2]

5、一个基本表达式和一个切片符号可以组成一个基本表达式
> []int{1,2,3,4,5}[1:4] 取出切片的第二个到第四个元素

6、一个基本表达式和一个类型断言符号可以组成一个基本表达式
> interface{}(num).(int) 判断一个int8类型的变量num是否是int类型

7、一个基本表达式和一个调用符号组成另外一个基本表达式
调用符号只针对于函数或者方法
> os.Open("/etc/profile") 表示对代码包os中的函数Open的调用

#### 选择符号和选择表达式

x.f  x必须代表一个至少拥有字段或方法的某个类型的值。在Go语言中，符合此要求的类型有结构体类型和接口类型.另外,f不能是空标识符。还记得空标识符吗？空标识符用"_"来表示。

选择符号可以用于调用任意深度的类型值的字段或者方法。

### 可变长函数
> func appendIfAbsent(s []string, t ...string) []string

它的调用表达式
> appendIfAbsent([]string{"A","B","C"},"C","B","E")

或者
> appendIfAbsent([]string{"A","B","C"},[]string{"C","B","E"}...)

### 数据类型
基本数据类型

![在这里输入图片描述][1]

> 一个byte(字节)等于8bit(比特)


  [1]: https://coding.net/api/project/183721/files/672519/imagePreview

